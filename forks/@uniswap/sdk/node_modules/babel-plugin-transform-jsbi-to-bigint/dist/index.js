"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the “License”);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// <https://apache.org/licenses/LICENSE-2.0>.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an “AS IS” BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// https://github.com/GoogleChromeLabs/jsbi#how
var binaryFunctionToExpression = new Map([['add', '+'], ['subtract', '-'], ['multiply', '*'], ['divide', '/'], ['remainder', '%'], ['exponentiate', '**'], ['leftShift', '<<'], ['signedRightShift', '>>'], ['bitwiseAnd', '&'], ['bitwiseOr', '|'], ['bitwiseXor', '^'], ['equal', '==='], ['notEqual', '!=='], ['lessThan', '<'], ['lessThanOrEqual', '<='], ['greaterThan', '>'], ['greaterThanOrEqual', '>='], ['EQ', '=='], ['NE', '!='], ['LT', '<'], ['LE', '<='], ['GT', '>'], ['GE', '>='], ['ADD', '+']]); // https://github.com/GoogleChromeLabs/jsbi#how

var unaryFunctionToExpression = new Map([['unaryMinus', '-'], ['bitwiseNot', '~']]); // https://github.com/GoogleChromeLabs/jsbi#how

var staticMethods = new Set(['asIntN', 'asUintN']);
var DATA_IDENTIFIER = 'JSBI';

function _default(babel) {
  var t = babel.types;

  var createExpression = function createExpression(path, name, args) {
    if (name === 'BigInt') {
      return createBigIntConstructor(path);
    }

    if (binaryFunctionToExpression.has(name)) {
      if (args.length !== 2) {
        throw path.buildCodeFrameError('Binary operators must have exactly two arguments');
      }

      return t.binaryExpression(binaryFunctionToExpression.get(name), args[0], args[1]);
    }

    if (unaryFunctionToExpression.has(name)) {
      if (args.length !== 1) {
        throw path.buildCodeFrameError('Unary operators must have exactly one argument');
      }

      return t.unaryExpression(unaryFunctionToExpression.get(name), args[0]);
    }

    if (staticMethods.has(name)) {
      if (args.length !== 2) {
        throw path.buildCodeFrameError('Static methods must have exactly two arguments');
      }

      return t.callExpression(t.memberExpression(t.identifier('BigInt'), t.identifier(name)), args);
    }

    if (name === 'toNumber') {
      if (args.length !== 1) {
        throw path.buildCodeFrameError('toNumber must have exactly one argument');
      }

      return t.callExpression(t.identifier('Number'), args);
    }

    throw path.buildCodeFrameError("Unknown JSBI function '".concat(name, "'"));
  };

  var createBigIntConstructor = function createBigIntConstructor(path) {
    var reInteger = /^(?:0|[1-9][0-9]*)$/;
    var arg = path.node.arguments[0];

    if (t.isNumericLiteral(arg) || t.isStringLiteral(arg) && reInteger.test(arg.value)) {
      return t.bigIntLiteral("".concat(arg.value, "n"));
    }

    return t.callExpression(t.identifier('BigInt'), [arg]);
  };

  var getPropertyName = function getPropertyName(path) {
    var node = path.node;
    if (t.isIdentifier(node)) return node.name;
    if (t.isStringLiteral(node)) return node.value;
    throw path.buildCodeFrameError('Only .BigInt or [\'BigInt\'] allowed here.');
  };

  var resolveBinding = function resolveBinding(_path, name) {
    var binding = _path.scope.getBinding(name);

    if (binding === undefined) return;
    var path = binding.path;
    if (path.getData(DATA_IDENTIFIER)) return binding;
    var init = path.node.init;

    if (t.isVariableDeclarator(path) && t.isMemberExpression(init)) {
      return resolveBinding(path.get('init'), init.object.name);
    }

    return binding;
  };

  var getJSBIProperty = function getJSBIProperty(path, name) {
    var binding = resolveBinding(path, name);
    return binding && binding.path.getData(DATA_IDENTIFIER);
  };

  var setJSBIProperty = function setJSBIProperty(path, data) {
    return path.setData(DATA_IDENTIFIER, data);
  };

  var hasJSBIProperty = function hasJSBIProperty(path, name) {
    return getJSBIProperty(path, name) !== undefined;
  };

  return {
    pre: function pre() {
      this.remove = new Set();
    },
    visitor: {
      Program: {
        exit: function exit() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.remove[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var path = _step.value;
              path.remove();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      },
      ImportDeclaration: function ImportDeclaration(path) {
        var source = path.node.source;

        if (t.isStringLiteral(source) && ( // Match exact "jsbi" or ".../jsbi.mjs" paths.
        /^jsbi$/i.test(source.value) || /[/\\]jsbi\.mjs$/i.test(source.value))) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = path.get('specifiers')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var specifier = _step2.value;

              if (t.isImportDefaultSpecifier(specifier)) {
                setJSBIProperty(specifier, '');
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          this.remove.add(path);
        }
      },
      VariableDeclarator: function VariableDeclarator(path) {
        var init = path.node.init;

        if (t.isMemberExpression(init)) {
          if (hasJSBIProperty(path, init.object.name)) {
            setJSBIProperty(path, getPropertyName(path.get('init.property')));
            this.remove.add(path);
          }
        }
      },
      CallExpression: function CallExpression(path) {
        var callee = path.node.callee;

        if (t.isMemberExpression(callee) && hasJSBIProperty(path, callee.object.name)) {
          // Handle usage via `JSBI.foo(bar)`.
          path.replaceWith(createExpression(path, getPropertyName(path.get('callee.property')), path.node.arguments));
        } else {
          // Handle usage via `JSBigInt = JSBI.BigInt; JSBigInt(foo)`.
          var jsbiProp = getJSBIProperty(path, callee.name);

          if (jsbiProp) {
            path.replaceWith(createExpression(path, jsbiProp, path.node.arguments));
          }
        }
      },
      BinaryExpression: function BinaryExpression(path) {
        var _path$node = path.node,
            operator = _path$node.operator,
            left = _path$node.left,
            right = _path$node.right;

        if (operator === 'instanceof' && t.isIdentifier(right, {
          name: 'JSBI'
        })) {
          path.replaceWith(t.binaryExpression('===', t.unaryExpression('typeof', left), t.stringLiteral('bigint')));
        }
      }
    }
  };
}